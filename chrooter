#!/bin/sh
# Abstract: CHange ROOT into desired directory (chrooter).
# Created by github.com/kreyren under GNUv3 (https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)

### START OF KREYPI INIT ###
# https://github.com/RXT067/Scripts/tree/kreyren/kreypi

# Sanitycheck for fetch
if ! command -v 'wget' >/dev/null && [ ! -e "/lib/bash/kreypi.bash" ]; then
    printf 'FATAL: %s\n' "This script requires 'wget' to be executable for downloading of kreypi (https://github.com/RXT067/Scripts/tree/kreyren/kreypi) for further sourcing\n"
    exit 1
fi

# Sanitycheck for /lib/bash
# shellcheck disable=SC2154
if [ ! -e "/lib/bash" ]; then
    mkdir -p "/lib/bash" || printf 'ERROR: %s\n' "Unable to make a new directory in /lib/bash"
    exit 1
elif [ -e "/lib/bash" ]; then
    [ -n "$debug" ] && printf 'DEBUG: %s\n' "Directory in '/lib/bash' already exists\n"
fi

# Fetch
if [ ! -e "/lib/bash/kreypi.bash" ]; then
    wget https://raw.githubusercontent.com/RXT067/Scripts/kreyren/kreypi/kreypi.bash -O '/lib/bash/kreypi.bash' || printf 'FATAL: %s\n' "Unable to download kreypi from 'https://raw.githubusercontent.com/RXT067/Scripts/kreyren/kreypi/kreypi.bash' in '/lib/bash/kreypi.bash'"
    exit 1
elif [ -e "/lib/bash/kreypi.bash" ]; then
    [ -n "$debug" ] && printf 'DEBUG: %s\n' "File '/lib/bash/kreypi.bash' already exists"
fi

# Source
if [ -e "/lib/bash/kreypi.bash" ]; then
    # 'source' can not be used on POSIX sh
    # shellcheck disable=SC1091
    . "/lib/bash/kreypi.bash" || { printf "FATAL: Unable to source '/lib/bash/kreypi.bash'\n" ; exit 1 ;}
    [ -n "$debug" ] && printf "DEBUG: Kreypi in '/lib/bash/kreypi.bash' has been successfully sourced"
elif [ ! -e "/lib/bash/kreypi.bash" ]; then
	printf "FATAL: Unable to source '/lib/bash/kreypi.bash' since path doesn't exists\n"
fi

### END OF KREYPI INIT ###

# Sanitization for Mount Directory variable
sanitize_mount_directory() {
    destdir="$1"

    # Sanity check for destdir
	if [ -z "$destdir" ]; then
        die 2 "Function 'sanitize_mount_directory' expects argument with path to mount directory which is not provided"

    elif [ -n "$destdir" ]; then
        debug "Variable destdir in function 'saniti' is set on '$destdir'"

        # Check if destdir is valid directory
        if [ ! -d "$destdir" ]; then
            die 1 "First argument '$destdir' in function 'sanitize_mount_directory' is not a valid directory"
        elif [ -d "$destdir" ]; then
            debug "In function 'sanitize_mount_directory' variable destdir stores a value of valid directory"
        else
            die 255 "sanitize_mount_directory, destdir directory check"
        fi

        # Enforce FSH-3.0
	    case "$destdir" in
            '/mnt/*') true ;;
            *) warn "Mount directories should be mounted in /mnt directory not $destdir"
        esac

        if [ ! -e "$destdir/etc" ] && [ -z "$forced" ]; then
            die 1 "Unable to find /etc directory in $destdir directory, assuming invalid mount directory, use --force to override if needed."
        elif [ ! -e "$destdir/etc" ] && [ -n "$forced" ]; then
            debug "Directory '$destdir/etc' is not found, but forced is used"
        else
            die 255 "sanitize_mount_directory, destdir/etc check"
        fi

    else
        die 255 "sanitize_mount_directory, destdir"

    fi

    unset destdir
}

# Mount required filesystems for chrooting
## Reference: https://wiki.gentoo.org/wiki/Chroot#Configuration
mount_required_fs() {
    destdir="$1"

	# Sanitization - Expecting $destdir="/mnt/something"
	sanitize_mount_directory "$destdir"

	# Mount /dev
	if ! grep -qF "$destdir/dev" /proc/mounts; then
        mount --rbind /dev "$destdir/dev/" || die 1 "Unable to mount '/dev' as rbind on '$destdir/dev'" 
        mount --make-rslave "$destdir/dev" || die 1 "Unable to mount '/dev' as '-make-rslave' on '$destdir/dev'"
    elif ! grep -qF "$destdir/dev" /proc/mounts; then
        # FIXME: This may output if --rbind above fails
        debug "Directory '$destdir/dev' is already mounted"
    else
        die 255 "mount_reguired_fs, dev"
    fi

	# Mount /sys
	if ! grep -qF "$destdir/sys" /proc/mounts; then
        mount --bind /sys "$destdir/sys/" || die 1 "Unable to mount '/sys' to '$destdir/sys' as bind which is required" 
    elif grep -qF "$destdir/sys" /proc/mounts; then
        debug "Directory '$destdir/sys' is already mounted"
    else
        die 255 "mount_required_fs, sys"
    fi

	# Mount /tmp
	if ! grep -qF "$destdir/tmp" /proc/mounts; then
        mount --rbind /tmp "$destdir/tmp" || die 1 "Unable to mount '$destdir/tmp' as '--bind' on '/tmp'"
        mount --make-rslave "$destdir/tmp" || die 1 "Unable to mount '/tmp' to '$destdir/tmp' as '--make-rbind' which is required"
    elif ! grep -qF "$destdir/tmp" /proc/mounts; then
        # FIXME: This may trigger if --rbind above failed
        debug "Directory '$destdir/tmp' is already mounted"
    else
        die 255 "mount_required_fs, tmp"
    fi

	# Mount /proc
	#if ! grep -qF "$destdir/proc" /proc/mounts;	then { mount --types proc none "$destdir/proc/" || die 0 "Unable to mount '/proc' on 'none' which is required";}; fi
	# HOTFIX, fuck everything
    # FIXME!
	mount --types proc none "$destdir/proc/" 2>/dev/null

    unset destdir
}

# Perform chroot
chrooter() {
    destdir="$1"
    command="$2"

	# Sanitization - Expecting $destdir="/mnt/something"
	sanitize_mount_directory "$destdir"

	# Mount everything in chroot
    # FIXME: Sanitize
	{ chroot "$destdir" mount -a && info "filesystems has been mounted on $destdir" ;} || warn "Unable to mount all filesystems on $destdir"

	# Perform chroot
	if [ -n "$command" ]; then
        chroot "$destdir" "$command" || die 0 "Unable to Change root from '$destdir' with command '$command'"
	elif [ -z "$command" ]; then
        chroot "$destdir" /bin/bash || die 0 "Unable to Change root from '$destdir' to /bin/bash"
	fi

    unset destdir command
}

# Take down chroot
kill_chrooter() {
    destdir="$1"

	# Sanitization - Expecting $destdir="/mnt/something"
	sanitize_mount_directory "$destdir"

	if [ "$(mount | grep -o "$destdir" -m '1')" = "$destdir" ]; then
        fixme "Unable to kill chroot on runtime (/dev preventing umount)"
        umount -R "$destdir" || die 1 "Unable to unmount $destdir"
	elif ! grep -qF "$destdir" /proc/mounts; then
        info "Directory $destdir is already not mounted, skipping.."
        return 0
    else
        die 255 "kill_chrooter, checking for destdir"
    fi
}

# CODE
checkroot "$@"

while [ "$#" -gt 1 ]; do case "$1" in
	-f|--force) export forced="KREYREN"; shitf 1 ;;
	-K|--kill) kill_chrooter "$2" ;;
    # Allow full path only
	/*)
		mount_required_fs "$1"

		chrooter "$1" "$2"

		if [ -n "$2" ]; then
            shift 2
        elif [ -n "$1" ] && [ -z "$2" ]; then
            shift 1
        else
            die 255 "Arguments, shifting of full unix path"
        fi
	;;
	*) die 2 "Unrecognized argument '$1' was parsed"
esac; done
