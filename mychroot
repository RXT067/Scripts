#!/bin/bash
# Name        : KreyMyChroot (KMS)
# Description : KreyMyChroot uses environment variables to chroot into available filesystems on multiboot systems
# Author      : github.com/kreyren
# Licence     : GPLv2 (https://www.gnu.org/licenses/old-licenses/gpl-2.0.cs.html)

## IMPROVEMENT 1+2
#<01> kreyren: see following example:
#<01> # ...() {   declare -A osnames=([gentoo]= [ubuntu]= [LFS]= [OpenSUSE]=);  if [[ $1 == --* && -v osnames["${1#--}"] ]]; then  echo -n checkroot "$@" '...  ';  set -- "${1#--}"; set -- "${1^^}";  echo '$@ is now' "$@";  DIR=/mnt/$1;  echo 'DIR is now' "$DIR";  else   echo showhelp;  fi; };    ... --gentoo
#<shbot> 01: checkroot --gentoo ...  $@ is now GENTOO
#<shbot> 01: DIR is now /mnt/GENTOO
#<01> # ...() {   declare -A osnames=([gentoo]= [ubuntu]= [LFS]= [OpenSUSE]=);  if [[ $1 == --* && -v osnames["${1#--}"] ]]; then  echo -n checkroot "$@" '...  ';  set -- "${1#--}"; dirname=$1;  set -- "${1^^}";  echo '$@ is now' "$@";  DIR=/mnt/$dirname;  echo 'DIR is now' "$DIR";  else   echo showhelp;  fi; };    ... --ubuntu
#<shbot> 01: checkroot --ubuntu ...  $@ is now UBUNTU
#<shbot> 01: DIR is now /mnt/ubuntu
#<01> # ...() {   declare -A osnames=([gentoo]= [ubuntu]= [LFS]= [OpenSUSE]=);  if [[ $1 == --* && -v osnames["${1#--}"] ]]; then  echo -n checkroot "$@" '...  ';  set -- "${1#--}"; dirname=$1;  set -- "${1^^}";  echo '$@ is now' "$@";  DIR=/mnt/$dirname;  echo 'DIR is now' "$DIR";  else   echo showhelp;  fi; };    ... --OpenSUSE
#<shbot> 01: checkroot --OpenSUSE ...  $@ is now OPENSUSE
#<shbot> 01: DIR is now /mnt/OpenSUSE
#<01> # ...() {   declare -A osnames=([gentoo]= [ubuntu]= [LFS]= [OpenSUSE]=);  if [[ $1 == --* && -v osnames["${1#--}"] ]]; then  echo -n checkroot "$@" '...  ';  set -- "${1#--}"; dirname=$1;  set -- "${1^^}";  echo '$@ is now' "$@";  DIR=/mnt/$dirname;  echo 'DIR is now' "$DIR";  else   echo showhelp;  fi; };    ... something-else
#<shbot> 01: showhelp
#<kreyren> investigating ty for example
#<01> kreyren: you see how it works, right?  we are using parameter expansions  ${1#--}, ${1^^},
#<01> parameter expansions are explained in this channel's wiki:
#<01> !pe
#<greybot> Parameter Expansion expands parameters: "$foo", "$1". You can use it to perform string or array operations: "${file%.mp3}", "${0##*/}", "${files[@]: -4}". They should *always* be quoted. See: http://mywiki.wooledge.org/BashFAQ/073 and "Parameter Expansion" in man bash. Also see http://wiki.bash-hackers.org/syntax/pe.
#<01> set operations, like checking if an element is in a set or finding set intersections, are often implemented in bash using associative arrays
#<01> they are also explained in the wiki^
#<02> https://github.com/RXT067/Scripts/blob/5c05fb6b4cec5bd51b86b7b274bc2466e98de944/mychroot#L50 :) [a-z][1-9] ;) there also can be things like vda, hda
#<checkbot> 02: I think the problem is on line 50. You are missing a required space here. See 4 issues on https://shellcheck.net/?id=cb61796
#<01> !assoc
#<greybot> Associative Arrays map strings to strings (Bash 4): http://mywiki.wooledge.org/BashGuide/Arrays#Associative_Arrays
#<kreyren> `[a-z][1-9]` good idea, adapted
#<01> kreyren: you can check if special file (like /dev/sda1) is a disk using one of test or [ built-in commands or [[ syntax with -b test
#<01> # help test | grep -- '  -b '
#<shbot> 01:       -b FILE        True if file is block special.
#<kreyren> Noted, investigating

CALLME=KMC

dependency () {
	if [[ ! -x $(command -v chroot) ]]; then
		echo "FATAL: Command 'chroot' is not executable!"
		exit 0
	fi

	if [[ ! -x $(command -v mkdir) ]]; then
		echo "FATAL: Command 'mkdir' is not executable!"
		exit 0
	fi

	if [[ ! -x $(command -v mount) ]]; then
		echo "FATAL: Command 'mount' is not executable!"
		exit 0
	fi
}

# CHECK ROOT
checkroot () {
	if [[ $UID == 0 ]]; then
		echo "something" 2&> /dev/null
		#No need to bother with "wow you are roooot!!"

		elif [[ -x "$(command -v sudo)" ]]; then
			echo -e "\e[1;32m$CALLME:\e[0m Failed to aquire root permission, trying using sudo."
			sudo $0 "$@"
			exit 1

		#TODO: Add sudo alternatives

		elif [[ ! -x "$(command -v sudo)" ]]; then
			echo -e "\e[1;32m$CALLME:\e[0m Failed to aquire root permission, trying using su."
			su -c "$0 $@"
			exit 1

	fi
}

chroot-me-senpaii () {
DIR=/mnt/${1^^}

	while [[ GO != @(Y|y) ]]; do
		echo "We will mount and prepare for chroot to $DIR, continue? (y/n)"
		read GO
	done

	# Sanity check for ${1^^}_CHROOT
	while [[ ${1^^}_CHROOT =! "/dev/sd[a-z][1-9]" ]]; do
		echo "ERROR: ${1^^}_CHROOT is not /dev/sd[a-z][1-9]"

		echo "(R)etry, (M)anuall"
		read CHOICE
		if [[ CHOICE == @(M|m) ]]; then
			# Expected /dev/{USER_INPUT}
			echo "Enter ${1^^}_CHROOT variable manually:"
			read ${1^^}_CHROOT
		fi
	done

	# Create a directory for chroot
	if [[ ! -e $DIR ]]; then
		mkdir -p $DIR || echo "FATAL: Unable to make new directory $DIR." && exit 0
	fi

	# Chroot in
	mount ${1^^}_CHROOT $DIR || echo "FATAL: Mounting ${1^^}_CHROOT to $DIR failed!" && exit 0
	mount --rbind /dev $DIR/dev || echo "ERROR: Unable to rbind /dev to $DIR/dev." 
	mount --make-rslave $DIR/dev || echo "ERROR: Unable to make-rslave of $DIR/dev."
	mount -t proc /proc $DIR/proc || echo "ERROR: Unable to mount proc."
	mount --rbind /sys $DIR/sys || echo "ERROR: Unable to rbind /sys to $DIR/sys"
	mount --make-rslave $DIR/sys || echo "ERROR: Unable to make-rslave of $DIR/tmp"
	mount --rbind /tmp $DIR/tmp || echo "ERROR: Unable to rbind /tmp to $DIR/tmp"
}


case $1 in
	*)
		checkroot $@
		dependency
		chroot-me-senpaii
esac